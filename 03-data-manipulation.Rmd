# Manipulating Plots with the grid Package

Ok, so now we have seen how to produce a variety of widely used plot types using both **lattice** and **ggplot2**. I hope that, apart from the specifics, you also obtained a general idea of how these two packages work and how you may use the various things we've touched upon here in scenarios other than the ones provided here.

Now, we're moving on to a more basic and much more flexible level of modifying, constructing and arranging graphs. Both, **lattice** and **ggplot2** are based upon the ```grid``` package. This means that we can use this package to fundamentally modify whatever we've produced (remember, we're always storing our plots in objects) in a much more flexible way that provided by any pf these packages.

With his ```grid``` package, Paul Murrell has achieved nothing less than a, in my opinion, much more flexible and powerful plotting framework for R. As a side note, this has already been 'officially' recognized as he is now member of the core team (at least I think so) and his ```grid``` package is now shipped with the base version of R. This means that we don't have to install the package anymore (however, we still have to load it via ```library(grid)```.

In order to fully appreciate the possibilities of the ```grid``` package, it helps to think of this package as a package for **drawing** things. Yes, we're not producing statistical plots as such (for this we have **lattice** and **ggplot2**), we're actually *drawing** things!

The fundamental features of the ```grid``` package are the ```viewports```. By default, the whole plotting area, may it be the standard R plotting device or the `png()` plotting device, is considered as the root viewport (basically like the ```home/<username>``` folder on your Linux system or the ```C:\Users\<username>``` folder in Windows). In this viewport we now have the possibility to specify other viewports which are relative to the root viewport (just like the ```Users<username>\Documents``` folder in Windows or - to provide a different example - the ```home/<username>/Downloads``` folder in Linux). 

The very important thing to realize here is that in order to do anything in this folder (be it creating another sub-folder or simply saving a file or whatever), we need to first **create** the folder and then we also need to **navigate/change/go** into the folder. If you keep this in mind, you will quickly understand the fundamental principle of ```grid```.

When we start using the ```grid``` package, we always start with the 'root' viewport. This is already available, it is created for us, so we don't need to do anything. This is our starting point. The really neat thing about ```grid``` is that each viewport is, by default, defined as both x and y ranging from 0 - 1. In the lower left corner x = 0 and y = 0. The lower right corner is x = 1 and y = 0, the upper right corner x = 1 & y = 1 and so on... It is, however, possible to specify a myriad of different unit systems (type, with the ```grid``` package loaded, ```?unit``` to get an overview of what is available). I usually stick to these default settings called `npc` ('Normalised Parent Coordinates') which range from 0 to 1 in each direction, as this makes setting up viewports very intuitive.

A viewport needs some basic specifications for it to be located somewhere in the plotting area (the current viewport). These are:

* x - the location along the x-axis
* y - the location along the y -axis
* width - the width of the viewport
* height - the height of the viewport
* just - the justification of the viewport in both x and y directions

Here, `width` and `height` should be rather self-explanatory. On the other hand, `x`, `y` and `just` are a bit more mind-bending. As default, `x` and `y` are 0.5 and `just` is `c(centre, centre)`. This means that the new viewport will be positioned at `x = 0.5` and `y = 0.5`. As the default of `just` is `centre` this means that a new viewport will be created at the midpoint of the current viewport (0.5, 0.5) and it will be centered on this point. It helps to think of the `just` specification in the same way that you provide your text justification in Word (left, right, centre & justified). Let us try a first example which should highlight the way this works

```{r, include = FALSE}
## this is needed to keep the graphical device open so that we can build 
## our layered grid figure
knitr::opts_knit$set(global.device = TRUE)
```

```{r grid-first-vp, tidy = FALSE, fig.cap = "Producing a standard viewport using **grid**.", fig.align = 'center'}
library(grid)
grid.newpage()

grid.rect()
grid.text("this is the root vp", x = 0.5, y = 1, 
          just = c("centre", "top"))

our_first_vp <- viewport(x = 0.5, y = 0.5, 
                         height = 0.5, width = 0.5,
                         just = c("centre", "centre"))

pushViewport(our_first_vp)

grid.rect(gp = gpar(fill = "pink"))
grid.text("this is our first vp", x = 0.5, y = 1, 
          just = c("centre", "top"))
```

Ok, so now we have created a viewport in the middle of the `root` viewport at `x = 0.5` and `y = 0.5` - `just = c("centre", "centre")` that is half the height and half the width of the original viewport - `height = 0.5` and `width = 0.5`.

Afterwards we navigated into this viewport - `pushViewport(our_first_vp)` and then we have drawn a rectangle that fills the entire viewport and filled it in pink color - `grid.rect(gp = gpar(fill = "pink"))`

Note that we didn't leave the viewport yet. This means, whatever we do now, will happen in the currently active viewport (the pink one). To illustrate this, we will simply repeat the exact same code from above once more.

```{r grid-second-vp, tidy = FALSE, fig.cap = "Producing a second viewport using **grid**.", fig.align = 'center'}
our_first_vp <- viewport(x = 0.5, y = 0.5, 
                         height = 0.5, width = 0.5,
                         just = c("centre", "centre"))

pushViewport(our_first_vp)

grid.rect(gp = gpar(fill = "cornflowerblue"))
```

This means, that whatever viewport we are currently in, this defines our reference system (0 to 1). In case you don't believe me, we can repeat this 10 times more...

```{r grid-several-vps, tidy = FALSE, fig.cap = "Producing several viewports using **grid**.", fig.align = 'center'}
for (i in 1:10) {
  our_first_vp <- viewport(x = 0.5, y = 0.5, 
                           height = 0.5, width = 0.5,
                           just = c("centre", "centre"))
  
  pushViewport(our_first_vp)
  
  grid.circle(gp = gpar(fill = colors()[i*3]))
}
```

I hope this is proof enough now! We are cascading down viewports always creating a rectangle that fills half the 'mother' viewport each time. Yet, as the 'mother' viewport becomes smaller and smaller, our rectangles also become smaller at each step along the way (programmers would actually call these steps iterations, but we won't be bothered here...)

So, how do we navigate back?

If I counted correctly, we went down 12 rabbit holes. In order to get out of these again, we need to `upViewport(12)` and in order to see whether we are correct, we ask ```grid``` what viewport we are currently in.


```{r grid-back-to-root-vp, tidy = FALSE, fig.keep = 'none'}
upViewport(12)

current.viewport()
```

Sweet, we're back in the 'root' viewport...

Now, let's see how this `just` parameter works. As you have seen we are now in the `root` viewport. Let's try to draw another rectangle that sits right at the top left corner of the pink one. In theory the lower right corner of this viewport should be located at `x = 0.25` and `y = 0.75`. If we specify it like this, we need to adjust the justification, because we do not want to center it on these coordinates. If these coordinates are the point of origin, this viewport should be justified right horizontally and bottom vertically. And the space we have to plot should be `0.25` vertically and `0.25` horizontally. Let's try this...

```{r grid-top-left-vp, tidy = FALSE, fig.cap = "Producing yet another viewport using **grid**.", fig.align = 'center'}
top_left_vp <- viewport(x = 0.25, y = 0.75, 
                        height = 0.25, width = 0.25,
                        just = c("right", "bottom"))

pushViewport(top_left_vp)

grid.rect(gp = gpar(fill = "grey", alpha = 0.5))
```

```{r dev2, include = FALSE}
## close the graphical device again
knitr::opts_knit$set(global.device = FALSE)
invisible(dev.off())
```

I hope that you have understood 2 things now:

1. How to create and navigate between viewports, and
2. Why I said earlier that `grid` is a package for drawing.

Assuming that you have understood these two points, let's make use of the first one and use this incredibly flexible plotting framework for arranging multiple plots on one page.


## `r tools::toTitleCase("Multiple Plots per page")`

**In order to succeed plotting several of our previously created plots on one page, there's two things of importance:**

1. The `lattice/ggplot2` plot objects need to be printed using `print(latticeObject)/print(ggplot2Object)`, and
2. We need to set `newpage = FALSE` in the print call so that the previously drawn elements are not deleted.

Let's try and plot some **lattice** and `ggplot2` plots next to each other on one page by setting up a suitable viewport structure. First of all we obviously need to produce plots. We will produce very basic plots here, but this should work with whatever `lattice` or `ggplot2` object you have created earlier.

```{r grid-multiple, message = FALSE, tidy = FALSE, fig.cap = "Using **grid** to place multiple plots on one page.", fig.align = 'center', fig.width = 10, fig.height = 10}

p1_lattice <- xyplot(price ~ carat, data = diamonds)
p2_lattice <- histogram(~ price, data = diamonds)

p1_ggplot <- ggplot(aes(x = carat, y = price), data = diamonds) +
  geom_point()
p2_ggplot <- ggplot(diamonds, aes(x = price)) +
  geom_histogram()

### clear plot area
grid.newpage()

### define first plotting region (viewport)
vp1 <- viewport(x = 0, y = 0, 
                height = 0.5, width = 0.5,
                just = c("left", "bottom"),
                name = "lower left")

### enter vp1 
pushViewport(vp1)

### show the plotting region (viewport extent)
grid.rect()

### plot a plot - needs to be printed (and newpage set to FALSE)!!!
print(p1_lattice, newpage = FALSE)

### leave vp1 - up one level (into root vieport)
upViewport(1)

### define second plot area
vp2 <- viewport(x = 1, y = 0, 
                height = 0.5, width = 0.5,
                just = c("right", "bottom"),
                name = "lower right")

### enter vp2
pushViewport(vp2)

### show the plotting region (viewport extent)
grid.rect()

### plot another plot
print(p2_lattice, newpage = FALSE)

### leave vp2
upViewport(1)


vp3 <- viewport(x = 0, y = 1, 
                height = 0.5, width = 0.5,
                just = c("left", "top"),
                name = "upper left")

pushViewport(vp3)

### show the plotting region (viewport extent)
grid.rect()

print(p1_ggplot, newpage = FALSE)

upViewport(1)


vp4 <- viewport(x = 1, y = 1, 
                height = 0.5, width = 0.5,
                just = c("right", "top"),
                name = "upper right")

pushViewport(vp4)

### show the plotting region (viewport extent)
grid.rect()

print(p2_ggplot, newpage = FALSE)

upViewport(1)
```

So there we have it. Creating and navigating between viewports enables us to build a graphical layout in whatever way we want. In my opinion this is way better than saving all the plots to the hard drive and then using some sort of graphics software such as [Adobe Photoshop](https://de.wikipedia.org/wiki/Adobe_Photoshop) or [Inkscape](https://de.wikipedia.org/wiki/Inkscape) to arrange the plots onto one page. After all, sometimes we may have several of these multi-plot-pages that we want to produce and now we know how to do this automatically and we won't need any post-production steps.


## `r tools::toTitleCase("manipulating existing plots")`

Another application of `grid` is to manipulate an existing plot object. You may have noted that our version of the 2D density scatter plot produced with `lattice` lacks a color key. This can be easily added using `grid`. As `lattice` is built upon `grid`, it produces a lot of viewports in the creation of the plots (like our scatter plot). We can, after they have been set up, navigate to each of these and edit them or delete them or add new stuff. Looking at the `ggplot2` version of the density scatter, we see that this has a color key which is placed to right of the main plot. Given that we have 5 panels, we actually have some 'white' space that we could use for the color key placement, thus making better use of the available space...

In order to do so, we need to know into which of the viewports created by `lattice` we need to navigate. Therefore, we need to know their names. `lattice` provides a function for this. We can use `trellis.vpname()` to extract the name(s) of the viewport(s) we are interested in. `lattice` provides a structured naming convention for its viewports. We can use this to specify what viewport name(s) we want to extract. As we are interested in the viewport that comprises the main figure, we will tell `lattice` to extract this name (see below in the code). Then we can navigate into this viewport `downViewport()` and set up a new viewport in the main plotting area (the figure viewport) to make use of the existing 'white' space. Remember that the default units of `grid` are 0 - 1. This means that we can easily calculate the necessary viewport dimensions. Let's see how this is done (Note, we are actually creating 2 new viewports in the figure area, one for the color key and another one for the color key label).

```{r grid-manipulate, fig.width = 10, fig.height = 7, fig.cap = "Using **grid** to add a color key to an existing **lattice** plot object.", fig.align = 'center'}
my_theme <- trellis.par.get()
my_theme$strip.background$col <- "grey80"
my_theme$plot.symbol$pch <- 16
my_theme$plot.symbol$col <- "grey60"
my_theme$plot.polygon$col <- "grey90"

scatter_lattice <- xyplot(price ~ carat | cut, 
                          data = diamonds, 
                          panel = function(x, y, ...) {
                            panel.xyplot(x, y, ...)
                            lm1 <- lm(y ~ x)
                            lm1sum <- summary(lm1)
                            r2 <- lm1sum$adj.r.squared
                            panel.text(labels = 
                                         bquote(italic(R)^2 == 
                                                  .(format(r2, 
                                                           digits = 3))),
                                       x = 4, y = 1000)
                            panel.smoother(x, y, method = "lm", 
                                           col = "black", 
                                           col.se = "black",
                                           alpha.se = 0.3)
                            },
                          xscale.components = xscale.components.subticks,
                          yscale.components = yscale.components.subticks,
                          as.table = TRUE)

l_sc <- update(scatter_lattice, par.settings = my_theme)
xy <- kde2d(x = diamonds$carat, y = diamonds$price, n = 100) 
xy_tr <- con2tr(xy)
offset <- max(xy_tr$z) * 0.2
z_range <- seq(min(xy_tr$z), max(xy_tr$z) + offset, offset * 0.01)

l_sc <- update(scatter_lattice, aspect = 1, par.settings = my_theme, 
               between = list(x = 0.3, y = 0.3),
               panel=function(x,y) {
                 xy <- kde2d(x,y, n = 100) 
                 xy_tr <- con2tr(xy)                 
                 panel.levelplot(xy_tr$x, xy_tr$y, xy_tr$z, asp = 1,
                                 subscripts = seq(nrow(xy_tr)), 
                                 contour = FALSE, region = TRUE, 
                                 col.regions = c("white", 
                                                 rev(clrs_hcl(10000))),
                                 at = z_range)
                 lm1 <- lm(y ~ x)
                 lm1sum <- summary(lm1)
                 r2 <- lm1sum$adj.r.squared
                 panel.abline(a = lm1$coefficients[1], 
                              b = lm1$coefficients[2])
                 panel.text(labels = 
                              bquote(italic(R)^2 == 
                                       .(format(r2, digits = 3))),
                            x = 4, y = 1000)
                 #panel.xyplot(x,y) 
                 } 
               ) 


grid.newpage()
#grid.rect()
print(l_sc, newpage = FALSE)
#grid.rect()
downViewport(trellis.vpname(name = "figure"))
#grid.rect()
vp1 <- viewport(x = 1, y = 0, 
                height = 0.5, width = 0.3,
                just = c("right", "bottom"),
                name = "legend.vp")

pushViewport(vp1)
#grid.rect()

vp1_1 <- viewport(x = 0.2, y = 0.5, 
                  height = 0.7, width = 0.5,
                  just = c("left", "centre"),
                  name = "legend.key")

pushViewport(vp1_1)
#grid.rect()

key <- draw.colorkey(key = list(col = c("white", rev(clrs_hcl(10000))),
                                at = z_range), draw = TRUE)

seekViewport("legend.vp")
#grid.rect()
vp1_2 <- viewport(x = 1, y = 0.5, 
                  height = 1, width = 0.3,
                  just = c("right", "centre"),
                  name = "legend.text", angle = 0)

pushViewport(vp1_2)
#grid.rect()

grid.text("estimated point density", 
          x = 0, y = 0.5, rot = 270, 
          just = c("centre", "bottom"))

upViewport(3)

```

Not too complicated, is it? And, in comparison to the `ggplot2` version, we are utilizing the available space a bit more efficiently. Though, obviously, we could also manipulate the `ggplot2` density scatter plot (or any other plot) in a similar manner. 

I hope it became clear just how useful `grid` can be and how it provides us with tools which enable us to produce individual graphics that satisfy our needs. 

So far, we have put our efforts into plot creation. I think, by now, we have a few tools handy to achieve what we want, so let's see how we can save our graphics to our hard drive.