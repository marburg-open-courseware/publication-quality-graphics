# Data Visualization

```{r knitsetup, echo = FALSE, message = FALSE}
pkg <- c('ggplot2', 'latticeExtra', 'gridExtra', 'MASS', 
         'colorspace', 'plyr', 'Hmisc', 'scales')
jnk <- sapply(pkg, library, character.only = TRUE)
```

In the next few sections, we will produce several varieties of *scatter plots*, *box & whisker plots*, *plots with error bars*, *histograms* and *density plots*. All of these will first be produced using the **lattice** package and then an attempt is made to recreate these in (pretty much) the exact same way in **ggplot2**. First, the default versions are created and then we will see how they can be modified in order to produce plots that satisfy the requirements of most academic journals.    

We will see that some things are easier to achieve using **lattice**, some other things are easier in **ggplot2**, so it is good to learn how to use both of them...

Before we start, we need to load the necessary packages and data set again


```{r pkgs, eval = FALSE}
### here's a rather handy way of loading all packages that you need
### for your code to work in one go
pkg <- c("ggplot2", "latticeExtra", "gridExtra", "MASS", 
         "colorspace", "plyr", "Hmisc", "scales")
jnk <- sapply(pkg, library, character.only = TRUE)

### load the diamonds data set (comes with ggplot2)
data(diamonds)
```


## `r tools::toTitleCase("A few notes on using color")`

Before we start plotting our data, we need to spend some time to have a closer look at color representation of certain variables. A careful study of color-spaces (e.g., [here](http://statmath.wu.ac.at/~zeileis/papers/Zeileis+Hornik+Murrell-2009.pdf), [here](http://hclwizard.org/hcl-color-scheme/), [here](http://vis4.net/blog/posts/avoid-equidistant-hsv-colors/) or [here](https://en.wikipedia.org/wiki/HSL_and_HSV)) leads to the conclusion that the HCL color space is preferable when mapping a variable to color (be it factorial or continuous).

This color space is readily available in R through the package ```colorspace``` and the function of interest is called ```hcl()```.

In the code chunk that follows we will create a color palette that varies in both color (hue) and also luminance (brightness) so that this can be distinguished even in grey-scale (printed) versions of the plot. As a reference color palette we will use the 'Spectral' palette from clorobrewer.org which is also a multi-hue palette but represents a diverging color palette. Hence, each end of the palette will look rather similar when converted to grey-scale. 

```{r colors, tidy = FALSE, fig.width = 8, fig.height = 3}
library(RColorBrewer)

clrs_spec <- colorRampPalette(rev(brewer.pal(11, "Spectral")))
clrs_hcl <- function(n) {
  hcl(h = seq(230, 0, length.out = n), 
      c = 60, l = seq(10, 90, length.out = n), 
      fixup = TRUE)
  }

### function to plot a color palette
pal <- function(col, border = "transparent", ...)
{
 n <- length(col)
 plot(0, 0, type="n", xlim = c(0, 1), ylim = c(0, 1),
      axes = FALSE, xlab = "", ylab = "", ...)
 rect(0:(n-1)/n, 0, 1:n/n, 1, col = col, border = border)
}
```

So here's the Spectral palette from colorbrewer.org interpolated over 100 colors

```{r par1, echo = FALSE}
par(mar = c(.1, .1, .1, .1))
```

```{r spectr-pal, tidy = FALSE, fig.width = 8, fig.height = 3, fig.cap = "A diverging rainbow color palette from [ColorBrewer](http://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3).", fig.align = 'center'}
pal(clrs_spec(100))
```

And this is what it looks like in grey-scale

```{r spectr-pal-grey, tidy = FALSE, fig.width = 8, fig.height = 3, fig.cap = "Same palette as above in grey-scale.", fig.align = 'center'}
pal(desaturate(clrs_spec(100)))
```

We see that this palette varies in lightness from a very bright center to darker ends on each side. Note, that the red end is slightly darker than the blue end

This is quite ok in case we want to show some diverging data (deviations from a zero point - e.g. the mean). If we, however, are dealing with a sequential measure, such as temperature, or in our case the density of points plotted per some grid cell, we really need to use a sequential color palette. There are two common problems with sequential palettes:

1. We need to create a palette that maps the data accurately. This means that the perceived distances between the different hues utilized needs to reflect the distances between our data points. AND this distance needs to be constant, no matter between which two point of the palette we want to estimate their distance. Let me give you an example. Consider the classic 'rainbow' palette ([MATLAB](https://www.mathworks.com/products/matlab.html) refers to this as 'jet colors')

```{r rainb-pal, tidy = FALSE, fig.width = 8, fig.height = 3, fig.cap = "The classic rainbow color palette.", fig.align = 'center'}
pal(rainbow(100))
```

It becomes obvious that there are several thin bands in this color palette (yellow, aquamarine, purple) which do not map the distances between variable values accurately. That is, the distance between two values located in/around the yellow region of the palette will seem to change faster than, for example somewhere in the green region (and red and blue).

When converted to grey-scale this palette produces a hell of a mess...

```{r rainb-pal-grey, tidy = FALSE, fig.width = 8, fig.height = 3, fig.cap = "Same palette as above in grey-scale.", fig.align = 'center'}
pal(desaturate(rainbow(100)))
```

Note, that this palette is maybe the most widely used color coding palette for mapping a sequential continuous variable to color. We will see further examples later on...

I hope you get the idea that this is not a good way of mapping a sequential variable to color!

```hcl()``` produces so-called perceptually uniform color palettes and is therefore much better suited to represent sequential data.

```{r hcl-pal, tidy = FALSE, fig.width = 8, fig.height = 3, fig.cap = "An HCL based multi-hue color palette with increasing luminance towards the red end.", fig.align = 'center'}
pal(clrs_hcl(100))
```

We see that the different hues are spread constantly over the palette and therefore it is easy to estimate distances between data values from the changes in color.   
The fact that we also vary luminance here means that we get a very light color at one end (here the red end - which is a more of a pink tone than red). This might, at first sight, not seem very aesthetically pleasing, yet it enables us to encode our data even in grey-scale...

```{r hcl-pal-grey, tidy = FALSE, fig.width = 8, fig.height = 3, fig.cap = "Same palette as above in grey-scale.", fig.align = 'center'}
pal(desaturate(clrs_hcl(100)))
```

```{r dev1, echo = FALSE, message = FALSE}
invisible(dev.off())
```

As a general suggestion I encourage you to make use of the HCL color space whenever you can. But most importantly, it is essential to do some thinking before mapping data to color. The most basic question you always need to ask yourself is **what is the nature of the data that I want to show? - sequential, diverging or qualitative?** Once you know this, it is easy to choose the appropriate color palette for the mapping. A good place to start for choosing perceptually well thought through palettes is [ColorBrewer](http://www.colorbrewer2.org).

Ok, so now let's start with the classic statistical plot, the scatterplot...


## Scatter plots (lattice way)

Even with all the enhancements & progress made in the field of computer based graphics in recent years/decades, the best (as most intuitive) way to show the relationship between two continuous variables remains the scatter plot. Just like for the smoothest ride, the best shape of the wheel is still round.

If, from our original diamonds data set we wanted to see the relation between price and carat of the diamonds (or more precisely how price is influenced by carat), we would use a scatter plot.

```{r scatter-lattice, tidy = FALSE, out.width = "80%", fis.asp = 1, fig.cap = "A basic scatter plot produced with **lattice**.", fig.align = 'center'}
scatter_lattice <- xyplot(price ~ carat, data = diamonds)
scatter_lattice
```

What we see is that generally lower carat values tend to be cheaper. 

However, there is, especially at the high price end, a lot of scatter, i.e. there are diamonds of 1 carat that cost just as much as diamonds of 4 or more carat. Maybe this is a function of the cut? Let's see...

Another thing that we might be interested in is the nature and strength of the relationship that we see in our scatter plot. These plots are still the fundamental way of visualizing linear (and non-linear) statistics between 2 (or more) variables. In our case (and I said we will only be marginally touching statistics here) let's try to figure out what the linear relationship between x (cut) and y (price) is. Given that we are plotting cut on the y-axis and the general linear regression formula is ```y ~ a + b*x``` means that we are assuming that cut is influencing (determining) price, NOT the other way round!!

Lattice is a very powerful package that provides a lot of flexibility and power to create all sorts of tailor-made statistical plots. In particular, it is designed to provide an easy-to-use framework for the representation of some variable(s) conditioned on some other variable(s). This means, that we can easily show the same relationship from figure 1, but this time for each of the different quality levels (the variable ```cut``` in the diamonds data set) into which diamonds can be classified. These conditional subsets are called panels in lattice.

This is done using the ```|``` character just after the formula expression. So the complete formula would read:

```
y ~ x | g
``` 

In other words, `y` is a function of `x` conditional to the values in `g` (where `g` is usually a factorial variable). The code below shows how all of this is achieved.

* plot ```price ~ carat``` conditional to ```cut```
* draw the regression line for each panel
* also provide the _R^2_ value for each panel

```{r scatter-lattice-with-panels-and-line, tidy = FALSE, fig.cap = "A panel plot showing regression lines for each panel produced with **lattice**", fig.align = 'center'}
scatter_lattice <- xyplot(price ~ carat | cut, 
                          data = diamonds, 
                          panel = function(x, y, ...) {
                            panel.xyplot(x, y, ...)
                            lm1 <- lm(y ~ x)
                            lm1sum <- summary(lm1)
                            r2 <- lm1sum$adj.r.squared
                            panel.abline(a = lm1$coefficients[1], 
                                         b = lm1$coefficients[2])
                            panel.text(labels = 
                                         bquote(italic(R)^2 == 
                                                  .(format(r2, 
                                                           digits = 3))),
                                       x = 4, y = 1000)
                            },
                          xscale.components = xscale.components.subticks,
                          yscale.components = yscale.components.subticks,
                          as.table = TRUE)

scatter_lattice
```

This is where **lattice** becomes a bit more challenging, yet how do they say: with great power comes great complexity... Okay, maybe we didn't get this quote completely correct, but it certainly reflects the nature of ```lattice's``` flexibility: A lot of things are possible, but they need a bit more effort than accepting the default settings.

Basically, what we have done here is to provide a so-called panel function (actually, we have provided 3 of them).

But let's look at this step-by-step... 

As **lattice** is geared towards providing plots in small multiples (as [Edward Tufte](https://www.edwardtufte.com/tufte/) calls them) or panels it provides a ```panel = ``` argument to which we can assign certain functions that will be evaluated separately for each of the panels. There's a variety of pre-defined panel functions (such as the ones we used here - `panel.xyplot()`, `panel.abline`, `panel.text` and many more) but we can also define out own panel functions. This is why **lattice** is so versatile and powerful. Basically, writing panel functions is just like writing any other function in R (though some limitations do exist).

The important thing to note here is that ```x``` and ```y``` in the context of panel functions refer to the ```x``` and ```y``` variables we define in the plot definition, i.e. ```x = carat``` and ```y = price```. So, for the panel functions we can use this shorthand, like as we are doing in defining our linear model ```lm1 <- lm(y ~ x)```. This linear model will be calculated separately for each of the panels, which are basically nothing else than subsets of our data corresponding to the different levels of cut. Maybe it helps to think of this as a certain type of for loop:

```
for (level in levels(cut)) lm1 <- lm(price ~ carat)
```

This then enables us to access the outcome of this linear model separately for each panel and we can use ```panel.abline``` to draw a line in each panel corresponding to the calculated model coefficients ```a = Intercept``` and ```b = slope```. Hence, we are drawing the regression line which represents the line of least squares for each panel separately.

The same holds true for the calculation and plotting of the adjusted _R^2_ value for each linear model per panel. In this case we use the ```panel.text()``` function to 'write' the corresponding value into each of the panel boxes. The location of the text is determined by the ```x = ``` and ```y = ``` arguments. This is where some car needs to be taken, as in the ```panel.text()``` call ```x``` and ```y``` don't refer to the ```x``` and ```y``` variables of the global plot function (```xyplot()```) anymore, but rather represent the locations of where to position the text within each of the panel boxes in the units used for each of the axes (in our case ```x = 4``` and ```y = 1000```).

There's two more things to note with regard to panel functions

1. In order to draw what we originally intended to draw, i.e. the scatterplot, we need to provide a panel function that represents our initial intention. In our case this is the rather blank call ```panel.xyplot(x, y, ...)```. Without this, the points of our plot will not be drawn and we will get a plot that only shows the regression line and the text (feel free to try it!). This seems like a good place to introduce one of the most awkward (from a programming point of view) but at the same time most awesome (from a users point of view) things in the R language. The ```...``` are a shorthand for 'everything else that is possible in a certain function'. This is both a very lazy and at the same time a very convenient way of passing arguments to a function. Basically, this enables us to provide any additional argument that the function might be able to understand. Any argument that ```xyplot()``` is able to evaluate (understand) can be passed in addition to ```x``` and ```y```. Try ot yourself by, for example specifying ```col = "red"```. If we had not included ```, ...``` in the ```panel = function(x, y, ...)``` argument, the ```col = ``` definition would not be possible. Anyway, this is only a side note that is not really related to the topic at hand, so let's move on....

2. the order in which panel functions are supplied does matter. This means that the first panel function will be evaluated (and drawn) first, then the second, then the third and so on. Hence, if we were to plot the points of our plot on top of everything else, we would need to provide the ```panel.xyplot()``` function as the last of the panel functions.

Right, so now we have seen how to use panel functions to calculate and draw things specific to each panel. One thing I really dislike about **lattice** is the default graphical parameter settings, in particular colors. However, changing these is rather straight forward. We can easily create our own themes by replacing the default values for each of the graphical parameters individually and saving these as our own themes. The function that lets us access the default (or already modified) graphical parameter settings is called ```trellis.par.get()```. Assigning this to a new object, we can modify every entry of the default settings to our liking (remember ```str()``` provides a 'road map' for accessing individual bits of an object).

```{r latt-panel-scat2, tidy = FALSE, fig.cap = "A panel plot with modified settings of the **lattice** layout.", fig.align = 'center'}
my_theme <- trellis.par.get()
my_theme$strip.background$col <- "grey80"
my_theme$plot.symbol$pch <- 16
my_theme$plot.symbol$col <- "grey60"
my_theme$plot.polygon$col <- "grey90"

l_sc <- update(scatter_lattice, par.settings = my_theme, 
               layout = c(3, 2),
               between = list(x = 0.3, y = 0.3))

print(l_sc)
```

Apart from showing us how to change the graphical parameter settings, the above code chunk also highlights one of the very handy properties of **lattice** (which is also true for **ggplot2**). We are able to store any plot we create in an object and can refer to this object later. This enables us to simply ```update``` the object rather than having to define it over (and over) again.

Like many other packages, **lattice** has a companion called ```latticeExtra```. This package provides several additions/extensions to the core functionality of **lattice**. One of the very handy additions is a panel function called ```panel.smoother()``` which enables us to evaluate several linear and non-linear models for each panel individually. This means that we actually don't need to calculate these models 'by hand' for each panel, but can use this pre-defined function to evaluate them. This is demonstrated in the next code chunk.

Note that we are still calculating the linear model in order to be able to provide the _R^2_ value for each panel. We don't need ```panel.abline()``` to draw the regression line anymore. Actually, this is done using ```panel.smoother``` which also provides us with an estimation of the standard error related to the mean estimation of ```y``` for each ```x```. This may be hard to see, but there is a confidence band of the standard error plotted around the regression line in each panel. Note, unfortunately, the confidence intervals are very narrow so that they are hard to see in the plot below.

For an overview of possible models to be specified using ```panel.smoother()```, see ```?panel.smoother``` from ```latticeExtra```.

```{r latt-panel-smooth-scat, tidy = FALSE, fig.cap = "A panel plot showing regression lines and confidence intervals for each panel produced with **lattice**.", fig.align = 'center'}
scatter_lattice <- xyplot(price ~ carat | cut, 
                          data = diamonds, 
                          panel = function(x, y, ...) {
                            panel.xyplot(x, y, ...)
                            lm1 <- lm(y ~ x)
                            lm1sum <- summary(lm1)
                            r2 <- lm1sum$adj.r.squared
                            panel.text(labels = 
                                         bquote(italic(R)^2 == 
                                                  .(format(r2, 
                                                           digits = 3))),
                                       x = 4, y = 1000)
                            panel.smoother(x, y, method = "lm", 
                                           col = "black", 
                                           col.se = "black",
                                           alpha.se = 0.3)
                            },
                          xscale.components = xscale.components.subticks,
                          yscale.components = yscale.components.subticks,
                          as.table = TRUE)

l_sc <- update(scatter_lattice, par.settings = my_theme)

print(l_sc)
```

Having a look at the scatter plots we have produced so far, there is an obvious problem. There are so many points that it is impossible to determine their actual distribution. One way to address this problem could be to plot each point in a semi-transparent manner. I have tried this potential solution and found that it does not help a great deal (but please feel free, and I highly encourage, to try out yourself).

Hence, we need another way to address the over-plotting of points.

A potential remedy is to map the 2 dimensional space in which we plot to a grid and estimate the point density in each of the grid cells. This can be done using a so-called 2 dimensional kernel density estimator. We won't have the time to go into much detail about this method here, but we will see how this can be done...

To do this we need a so-called '2 dimensional kernel density estimator'. I won't go into much detail about the density estimation here. What is important for our purpose is that we actually need to estimate this twice. Once globally, meaning for the whole data set, in order to find the absolute extremes (minimum and maximum) of our data distribution. This is important for the color mapping, because the values of each panel need to be mapped to a common scale in order to interpret them. In other words, this way we are making sure that the similar values of our data are represented by similar shades of, let's say red.

However, in order to be able to estimate the density for each of our panels we also need to do the same calculation in our panel function. 

Essentially what we are creating is a gridded data set (like a photo) of the density of points within each of the defined pixels. The **lattice** function for plotting gridded data is called ```levelplot()```.

Here's the code

```{r latt-dens-scat, tidy = FALSE, fig.cap = "A **lattice** panel plot showing the point density within each panel.", fig.align = 'center'}
xy <- kde2d(x = diamonds$carat, y = diamonds$price, n = 100) 
xy_tr <- con2tr(xy)
offset <- max(xy_tr$z) * 0.2
z_range <- seq(min(xy_tr$z), max(xy_tr$z) + offset, offset * 0.01)

l_sc <- update(scatter_lattice, aspect = 1, par.settings = my_theme, 
               between = list(x = 0.3, y = 0.3),
               panel=function(x,y) {
                 xy <- kde2d(x,y, n = 100) 
                 xy.tr <- con2tr(xy)                 
                 panel.levelplot(xy_tr$x, xy_tr$y, xy_tr$z, asp = 1,
                                 subscripts = seq(nrow(xy_tr)), 
                                 contour = FALSE, region = TRUE, 
                                 col.regions = c("white", 
                                                 rev(clrs_hcl(10000))),
                                 at = z_range)
                 lm1 <- lm(y ~ x)
                 lm1sum <- summary(lm1)
                 r2 <- lm1sum$adj.r.squared
                 panel.abline(a = lm1$coefficients[1], 
                              b = lm1$coefficients[2])
                 panel.text(labels = 
                              bquote(italic(R)^2 == 
                                       .(format(r2, digits = 3))),
                            x = 4, y = 1000)
                 } 
               ) 

print(l_sc)
```

It should not go unnoted that there is a panel function in **lattice** that does this for you. The function is called ```panel.smoothScatter()``` and unless we need to specify a custom color palette, this is more than sufficient.

As a hint, if you want to use this panel function with your own color palette you need to make sure that your palette starts with white as otherwise things will look really weird...

```{r latt-smooth-scat, tidy = FALSE, fig.cap = "A **lattice** panel plot showing the point density within each panel using the panel function `smoothScatter()`.", fig.align = 'center'}
l_sc_smooth <- update(scatter_lattice, aspect = 1, 
                      par.settings = my_theme, 
                      between = list(x = 0.3, y = 0.3),
                      panel = panel.smoothScatter)

print(l_sc_smooth)
```

This representation of our data basically adds another dimension to our plot which enables us to see that no matter what the quality of the diamond, most of the diamonds are actually of low carat and low price. Whether this is good or bad news, depends on your interpretation (and the size of your wallet, of course).


## Scatter plots (ggplot2 way)

Now let's try to recreate what we have achieved with **lattice** using **ggplot2**.

**ggplot2** is radically different from the way that **lattice** works. **lattice** is much closer to the traditional way of plotting in R. There are different functions for different types of plots. In **ggplot2** this is different. Every plot we want to draw, is, at a fundamental level, created in exactly the same way. What differs are the subsequent calls on how to represent the individual plot components (basically ```x``` and ```y```). This means a much more consistent way of *building* visualizations, but it also means that things are rather different from what you might have learned about syntax and structure of (plotting) objects in R. But not to worry, even I managed to understand how thing are done in **ggplot2** (and prior to writing this I had almost never used it before).

Before I get carried away too much let's jump right into our first plot using **ggplot2**

```{r gg-scat, tidy = FALSE, fig.cap = "A basic scatter plot created with **ggplot2**.", fig.align = 'center'}
scatter_ggplot <- ggplot(aes(x = carat, y = price), data = diamonds)

g_sc <- scatter_ggplot + geom_point()

print(g_sc)
```

Similar to **lattice**, plots are (usually) stored in objects. But that is about all the similarity there is.

Let's look at the above code in a little more detail. The first line is the fundamental definition of **what** we want to plot. We provide the 'aesthetics' for the plot via ```aes()```. We state that we want the values on the x-axis to represent carat and the y-values are price. The data set to take these variables from is the diamonds data set. That's basically it, and this will not change a hell of a lot in the subsequent plotting routines.

What will change in the plotting code chunks that follow is **how** we want the relationship between these variables to be represented in our plot. This is done by defining so-called geometries (```geom_...()```). In this first case we stated that we want the relationship between ```x``` and ```y``` to be represented as points, hence we used ```geom_point()```.

If we wanted to provide a plot showing the relationship between price and carat in panels representing the quality of the diamonds, we need what in ```gglot2``` is called 'faceting' (panels in **lattice**). To achieve this, we simply repeat our plotting call from earlier and add another layer to the call which does the faceting.

```{r gg-facet-scat, tidy = FALSE, fig.cap = "The **ggplot2** version of a facetted plot.", fig.align = 'center'}
g_sc <- scatter_ggplot + 
  geom_point() +
  facet_wrap(~ cut)

print(g_sc)
```

One thing that some people dislike about the default settings in **ggplot2** is the grey background of the plots. This grey background is, in my opinion, a good idea when colors are involved as it tends to increase the contrast of the colors. If, however, the plot is a simple black-and-white scatter plot as in our case here, a white panel, or better facet background seems more reasonable. We can easily change this using a pre-defined theme called ```theme_bw()```.

In order to provide the regression line for each panel like we did in **lattice**, we need a function called ```stat_smooth()```. This is fundamentally the same function that we used earlier, as the ```panel.smoother()``` in **lattice** is based on ```stat_smooth()```.

Putting this together we could do something like this (note that we also change the number of rows and columns into which the facets should be arranged):

```{r gg-facet-smooth-scat, tidy = FALSE, fig.cap = "A **ggplot2** panel plot with modified theme and added regression lines and confidence bands for each panel.", fig.align = 'center'}
g_sc <- scatter_ggplot + 
  #geom_tile() +
  geom_point(color = "grey60") +
  facet_wrap(~ cut, nrow = 2, ncol = 3) +
  theme_bw() +
  stat_smooth(method = "lm", se = TRUE, 
              fill = "black", color = "black")

print(g_sc)
```

Simple and straight forward, and the result looks rather similar to the **lattice** version we created earlier.

Creating a point density scatter plot in **ggplot2** is actually a fair bit easier than in **lattice**, as ```gglot2``` provides several predefined ```stat_...()``` function calls. One of these is designed to create 2 dimensional kernel density estimations, just what we want. However, this is where the syntax of **ggplot2** really becomes a bit abstract. The definition of the fill argument of this call is ```..density..``` which, at least to me, does not seem very intuitive. 

Furthermore, it is not quite sufficient to supply the stat function, we also need to state how to map the colors to that stat definition. Therefore, we need yet another layer which defines what color palette to use. As we want a continuous variable (density) to be filled with a gradient of n colors, we need to use ```scale_fill_gradientn()``` in which we can define the colors we want to be used.

```{r gg-dens-scat, tidy = FALSE, fig.cap = "The **ggplot2** version of a panel plot showing point densities in each panel.", fig.align = 'center'}
g_sc <- scatter_ggplot + 
  geom_tile() +
  #geom_point(color = "grey60") +
  facet_wrap(~ cut, nrow = 3, ncol = 2) +
  theme_bw() +
  stat_density2d(aes(fill = ..density..), n = 100,
                 geom = "tile", contour = FALSE) +
  scale_fill_gradientn(colors = c("white",
                                   rev(clrs_hcl(100)))) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +
  coord_fixed(ratio = 5/30000)

print(g_sc)
```


## Box-and-Whisker Plots (lattice way)

I honestly don't have a lot to say about box and whisker plots. They are probably the most useful plots for showing the nature/distribution of your data and allow for some easy comparisons between different levels of a factor for example. See [here](http://upload.wikimedia.org/wikipedia/commons/1/1a/Boxplot_vs_PDF.svg) for a visual representation of the standard R settings of BW plots in relation to mean and standard deviation of a normal distribution.

So without further ado, here's a basic lattice box and whisker plot.

```{r latt-bw1, tidy = FALSE, fig.cap = "A basic box-and-whisker plot produced with **lattice**.", fig.align = 'center'}
bw_lattice <- bwplot(price ~ color, data = diamonds)
bw_lattice
```

Not so very beautiful... So, let's again modify the standard ```par.settings``` so that we get an acceptable box and whisker plot.

```{r latt-bw2, tidy = FALSE, fig.cap = "A **lattice** box-and-whisker plot with modified graphical parameter settings.", fig.align = 'center'}
bw_theme <- trellis.par.get()
bw_theme$box.dot$pch <- "|"
bw_theme$box.rectangle$col <- "black"
bw_theme$box.rectangle$lwd <- 2
bw_theme$box.rectangle$fill <- "grey90"
bw_theme$box.umbrella$lty <- 1
bw_theme$box.umbrella$col <- "black"
bw_theme$plot.symbol$col <- "grey40"
bw_theme$plot.symbol$pch <- "*"
bw_theme$plot.symbol$cex <- 2
bw_theme$strip.background$col <- "grey80"

l_bw <- update(bw_lattice, par.settings = bw_theme)

print(l_bw)
```

Much better, isn't it?

```{r latt-panel-bw, tidy = FALSE, fig.cap = "A **lattice** panel box-and-whisker plot with box widths relative to number of observations and colored boxes.", fig.align = 'center'}
bw_lattice <- bwplot(price ~ color | cut, data = diamonds,
                     asp = 1, as.table = TRUE, varwidth = TRUE)
l_bw <- update(bw_lattice, par.settings = bw_theme, xlab = "color", 
               fill = clrs_hcl(7),
               xscale.components = xscale.components.subticks,
               yscale.components = yscale.components.subticks)

print(l_bw)
```

In addition to the rather obvious provision of a color palette to fill the boxes, in this final box & whisker plot we have also told **lattice** to adjust the widths of the boxes so that they reflect the relative sizes of the data samples for each of the factors (colors). This is a rather handy way of providing insight into the data distribution along the factor of the x-axis. We can show this without having to provide any additional plot to highlight that some of the factor levels (i.e. colors) are much less represented than others ('J' compared to 'G', for example, especially for the 'Ideal' quality class). 


## Box-and-Whisker Plots (ggplot2 way)

As much as I love **lattice**, I always end up drawing box and whisker plots with **ggplot2** because they look so much nicer and there's no need to modify so many graphical parameter settings in order to get an acceptable result.

You will see what I mean when we plot a **ggplot2** version using the default settings.

```{r gg-bw1, tidy = FALSE, fig.cap = "A basic **ggplot2** box-and-whisker plot.", fig.align = 'center'}
bw_ggplot <- ggplot(diamonds, aes(x = color, y = price))

g_bw <- bw_ggplot + geom_boxplot()

print(g_bw)
```

This is much better straight away! And, as we've already seen, the faceting is also just one more line...

```{r gg-facet-bw, tidy = FALSE, fig.cap = "**ggplot2** panel box-and-whisker plot.", fig.align = 'center'}
bw_ggplot <- ggplot(diamonds, aes(x = color, y = price))

g_bw <- bw_ggplot + 
  geom_boxplot(fill = "grey90") +
  theme_bw() +
  facet_wrap(~ cut)

print(g_bw)
```

So far, you may have gotten the impression that pretty much everything is a little bit easier the **ggplot2** way. Well, a lot of things are, but some are not. If we wanted to highlight the relative sample sizes of the different color levels like we did earlier in **lattice** (using ```varwidth = TRUE```) we have to put a little more effort into **ggplot2**. Meaning, we have to calculate this ourselves. There is no built in functionality for this feature (yet), at least none that I am aware of.

But, it is not too complicated. The equation for this adjustment is rather straight forward, we simply take the square root of the counts for each color and divide it by the overall number of observations. Then we standardize this relative to the maximum of this calculation. As a final step, we need to break this down to each of the panels of the plot. This is the toughest part of it. I won't go into any detail here, but the ```llply()``` part of the following code chunk is basically the equivalent of what is going on behind the scenes of **lattice** (though **lattice** most likely does not use ```llply()```).

Anyway, it does not require too many lines of code to achieve the box width adjustment in **ggplot2**.

```{r gg-facet-width-bw, tidy = FALSE, fig.cap = "A **ggplot2** panel box-and-whisker plot with box widths relative to number of observations and colored boxes.", fig.align = 'center'}
w <- sqrt(table(diamonds$color)/nrow(diamonds))
### standardize w to maximum value
w <- w / max(w)

g_bw <- bw_ggplot + 
  facet_wrap(~ cut) +
  llply(unique(diamonds$color), 
        function(i) geom_boxplot(fill = clrs_hcl(7)[i],
                                 width = w[i], outlier.shape = "*",
                                 outlier.size = 3,
                                 data = subset(diamonds, color == i))) +
  theme_bw()

print(g_bw)
```

The result is very similar to what we have achieved earlier with **lattice**. In summary, lattice needs a little more care to adjust the standard graphical parameters, whereas **ggplot2** requires us to manually calculate the width of the boxes. I leave it up to you, which way suits you better... I have already made my choice a few years ago ;-)

Boxplots are, as mentioned above, a brilliant way to visualize data distribution(s). Their strength lies in the comparability of different classes as they are plotted next to each other using a common scale. Another, more classical - as parametric - way are histograms and density plots.


## Histograms and Density Plots (lattice way)

The classic way to visualize the distribution of any data are histograms. They are closely related to density plots, where the individual data points are not binned into certain classes but a continuous density function is calculated to show the distribution. Both approaches reflect a certain level of abstraction (binning vs. functional representation), therefore a general formulation of which of them is more accepted is hard. In any case, the both achieve exactly the same result, they will show us the distribution of our data.

As is to be expected with **lattice**, the default plotting routine does not really satisfy the (or maybe better my) aesthetic expectations.

```{r altt-hist, tidy = FALSE, fig.cap = "A basic histogram produced with **lattice**.", fig.align = 'center'}
hist_lattice <- histogram(~ price, data = diamonds)
hist_lattice
```

This is even worse for the default density plot...

```{r latt-dens, tidy = FALSE, fig.cap = "A basic density plot produced with **lattice**.", fig.align = 'center'}
dens_lattice <- densityplot(~ price, data = diamonds)
dens_lattice
```

Yet, as we've already adjusted our global graphical parameter settings, we can now easily modify this.

```{r latt-panel-hist, tidy = FALSE, fig.cap = "A **lattice** panel histogram with modified graphical parameter settings.", fig.align = 'center'}
hist_lattice <- histogram(~ price | color, 
                          data = diamonds,
                          as.table = TRUE,
                          par.settings = my_theme)

l_his <- hist_lattice

print(l_his)
```

Now, this is a plot that every journal editor will very likely accept.

Until now, we have seen how to condition our plots according to one factorial variable (```diamonds$cut```). It is, in theory, possible to condition plots on any number of factorial variable, though more than two is seldom advisable. Two, however, is definitely acceptable and still easy enough to perceive and interpret. In **lattice** this is generally done as follows.

```
y ~ x | g + f
```

where ```g``` and ```f``` are the factorial variables used for the conditioning.

In the below code chunk we are first creating out plot object and the we are using a function called ```useOuterStrips()``` which makes sure that the strips that correspond to the conditioning variables are plotted on both the top and the left side of our plot. The default **lattice** setting is to plot both at the top, which makes the navigation through the plot by the viewer a little more difficult.

Another default setting for density plots in **lattice** is to plot a point (circle) for each observation of our variable (price) at the bottom of the plot along the x--axis. In our case, as we have a lot of data points, this is not desirable, so we set ```plot.points = FALSE```.

```{r latt-panel-dens, tidy = FALSE, fig.cap = "A panel density plot conditioned according to 2 variables using **lattice**.", fig.align = 'center'}
dens_lattice <- densityplot(~ price | cut + color, 
                            data = diamonds,
                            as.table = TRUE,
                            par.settings = my_theme,
                            plot.points = FALSE,
                            between = list(x = 0.2, y = 0.2),
                            scales = list(x = list(rot = 45)))

l_den <- useOuterStrips(dens_lattice)

print(l_den)
```

You may have noticed that the lines of the density plot are plotted in a light shade of blue (cornflowerblue to be precise). I it up to you to change this yourself...

Another thing you may notice when looking at the above plot is that the x-axis labels are rotated by 45 degrees. This one I also leave up to you to figure out... ;-)


## Histograms and Density Plots (ggplot2 way)

Much like with the box-and-whisker plot, the default settings of **ggplot2** are quite a bit nicer for both histograms and density plots.

```{r gg-hist, tidy = FALSE, fig.cap = "A basic histogram produced with **ggplot2**.", fig.align = 'center'}
hist_ggplot <- ggplot(diamonds, aes(x = price))

g_his <- hist_ggplot +
  geom_histogram()

print(g_his)
```

One thing that is really nice about the **ggplot2** density plots that it is so easy to fill the area under the curve which really helps the visual representation of the data.

```{r gg-dens, tidy = FALSE, fig.cap = "A basic density plot produced with **ggplot2**.", fig.align = 'center'}
dens_ggplot <- ggplot(diamonds, aes(x = price))

g_den <- dens_ggplot +
  geom_density(fill = "black", alpha = 0.5)

print(g_den)
```

Just as before, we are encountering again the rather peculiar way of **ggplot2** to adjust certain default settings to suit our needs (likes). In we wanted to show percentages instead of counts for the histograms, we again need to use the strange ```..something..``` syntax.

Another thing I want to highlight in the following code chunk is the way to achieve binary conditioning in **ggplot2**. This is done as follows:

```
facet_grid(g ~ f)
```

where, again, ```g``` and ```f``` are the two variables used for conditioning.

```{r gg-facet-hist, tidy = FALSE, fig.cap = "A **ggplot2** panel histogram with y-axis labelled according to percentages.", fig.align = 'center', message = FALSE}
g_his <- hist_ggplot +
  geom_histogram(aes(y = ..ncount..)) +
  scale_y_continuous(labels = percent_format()) +
  facet_grid(color ~ cut) + 
  ylab("Percent")

print(g_his)
```

Similar to our **lattice** approach we're going to rotate the x-axis labels by 45 degrees.

```{r gg-facet-density, tidy = FALSE, fig.cap = "A **ggplot2** panel density plot conditioned according to 2 variables.", fig.align = 'center'}
dens_ggplot <- ggplot(diamonds, aes(x = price))

g_den <- dens_ggplot +
  geom_density(fill = "black", alpha = 0.5) +
  facet_grid(color ~ cut) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(g_den)
```

Ok, another thing we might want to show is the value of a certain estimated value (like the mean of our sample) including error bars.


## Plotting Error Bars (lattice way)

Honestly, **lattice** sucks at plotting error bars... Therefore, we will only explore one way of achieving this. In case you really want to explore this further, I refer you to StackOverflow and other R related forums and lists, where you will find a solution, but I doubt that you will like it... As you will see in Section `{#gg-err}`, error bars are much easier plotted using **ggplot2**.

```{r latt-err, tidy = FALSE, fig.cap = "A basic dotplot with error bars produced with **lattice**.", fig.align = 'center'}
my_theme$dot.symbol$col <- "black"
my_theme$dot.symbol$cex <- 1.5
my_theme$plot.line$col <- "black"
my_theme$plot.line$lwd <- 1.5

dmod <- lm(price ~ cut, data = diamonds)
cuts <- data.frame(cut = unique(diamonds$cut), 
                   predict(dmod, data.frame(cut = unique(diamonds$cut)), 
                           se = TRUE)[c("fit", "se.fit")])

errbar_lattice <- Hmisc::Dotplot(cut ~ Cbind(fit, 
                                             fit + se.fit, 
                                             fit - se.fit),
                                 data = cuts, 
                                 par.settings = my_theme)

l_err <- errbar_lattice

print(l_err)
```


## Plotting Error Bars (ggplot2 way) {#gg-err}

As mentioned above, when plotting error bars **ggplot2** is much easier. Whether this is because of the general ongoing discussion about the usefulness of these plots I do not want to judge.

Anyway, plotting error bars in **ggplot2** is as easy as everything else...

```{r gg-err, tidy = FALSE, fig.cap = "A basic dotplot with error bars produced with **ggplot2**.", fig.align = 'center'}
errbar_ggplot <- ggplot(cuts, aes(cut, fit, ymin = fit - se.fit, 
                                  ymax=fit + se.fit))
g_err <- errbar_ggplot + 
  geom_pointrange() +
  coord_flip() +
  theme_classic()

print(g_err)
```

Especially, when plotting them as part of a bar plot.

```{r gg-err-bar, tidy = FALSE, fig.cap = "A **ggplot2** bar plot with error bars.", fig.align = 'center'}
g_err <- errbar_ggplot + 
  geom_bar(stat = "identity", fill = "grey80") +
  geom_errorbar(width = 0.2) +
  coord_flip() +
  theme_classic()

print(g_err)
```

Just as before (with the box widths) though, applying this to each panel is a little more complicated...

```{r gg-facet-err-bar, tidy = FALSE, concordance = TRUE, fig.cap = "A **ggplot2** panel bar plot with error bars and modified fill colors.", fig.align = 'center'}
errbar_ggplot_facets <- ggplot(diamonds, aes(x = color, y = price))

### function to calculate the standard error of the mean
se <- function(x) sd(x)/sqrt(length(x))

### function to be applied to each panel/facet
myFun <- function(x) {
  data.frame(ymin = mean(x) - se(x), 
             ymax = mean(x) + se(x), 
             y = mean(x))
  }

g_err_f <- errbar_ggplot_facets + 
  stat_summary(fun.y = mean, geom = "bar", 
               fill = rep(clrs_hcl(7), 5)) + 
  stat_summary(fun.data = myFun, geom = "linerange") + 
  facet_wrap(~ cut) +
  theme_bw()

print(g_err_f)
```

Still, trust me on this, much easier than to achieve the same result in **lattice**.